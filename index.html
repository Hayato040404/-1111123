import React, { useState, useRef, useEffect } from 'react';
import { Camera, Mic, Square, Volume2, VolumeX, Film, Download, BarChart3 } from 'lucide-react';

export default function BaseballCommentary() {
  const [isStreaming, setIsStreaming] = useState(false);
  const [isCommenting, setIsCommenting] = useState(false);
  const [isSpeechEnabled, setIsSpeechEnabled] = useState(true);
  const [commentary, setCommentary] = useState('');
  const [allComments, setAllComments] = useState([]);
  const [motionLevel, setMotionLevel] = useState(0);
  const [gameStats, setGameStats] = useState({
    pitches: 0,
    hits: 0,
    catches: 0,
    runs: 0,
    totalMotion: 0,
    peakMotion: 0,
    duration: 0
  });
  const [highlights, setHighlights] = useState([]);
  const [showDigest, setShowDigest] = useState(false);
  
  const videoRef = useRef(null);
  const canvasRef = useRef(null);
  const streamRef = useRef(null);
  const previousFrameRef = useRef(null);
  const animationRef = useRef(null);
  const motionHistoryRef = useRef([]);
  const lastEventTimeRef = useRef(0);
  const startTimeRef = useRef(0);
  const durationIntervalRef = useRef(null);

  // 動き検出の詳細分析
  const analyzeMotion = () => {
    const video = videoRef.current;
    const canvas = canvasRef.current;
    if (!video || !canvas || video.readyState !== video.HAVE_ENOUGH_DATA) {
      return { overall: 0, center: 0, left: 0, right: 0, top: 0, bottom: 0 };
    }

    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    canvas.width = 160;
    canvas.height = 120;
    
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    const currentFrame = ctx.getImageData(0, 0, canvas.width, canvas.height);
    
    if (!previousFrameRef.current) {
      previousFrameRef.current = currentFrame;
      return { overall: 0, center: 0, left: 0, right: 0, top: 0, bottom: 0 };
    }

    const data = currentFrame.data;
    const prevData = previousFrameRef.current.data;
    const w = canvas.width;
    const h = canvas.height;
    
    // エリア別の動き検出
    const areas = {
      center: { x: Math.floor(w * 0.35), y: Math.floor(h * 0.3), w: Math.floor(w * 0.3), h: Math.floor(h * 0.4), sum: 0 },
      left: { x: 0, y: Math.floor(h * 0.2), w: Math.floor(w * 0.3), h: Math.floor(h * 0.6), sum: 0 },
      right: { x: Math.floor(w * 0.7), y: Math.floor(h * 0.2), w: Math.floor(w * 0.3), h: Math.floor(h * 0.6), sum: 0 },
      top: { x: Math.floor(w * 0.2), y: 0, w: Math.floor(w * 0.6), h: Math.floor(h * 0.3), sum: 0 },
      bottom: { x: Math.floor(w * 0.2), y: Math.floor(h * 0.7), w: Math.floor(w * 0.6), h: Math.floor(h * 0.3), sum: 0 }
    };

    let overallSum = 0;
    
    Object.keys(areas).forEach(key => {
      const area = areas[key];
      for (let y = area.y; y < area.y + area.h && y < h; y++) {
        for (let x = area.x; x < area.x + area.w && x < w; x++) {
          const i = (y * w + x) * 4;
          const diff = Math.abs(data[i] - prevData[i]) + 
                       Math.abs(data[i + 1] - prevData[i + 1]) + 
                       Math.abs(data[i + 2] - prevData[i + 2]);
          area.sum += diff;
          overallSum += diff;
        }
      }
      area.avg = area.sum / (area.w * area.h * 3);
    });

    previousFrameRef.current = currentFrame;
    
    return {
      overall: overallSum / (w * h * 3),
      center: areas.center.avg,
      left: areas.left.avg,
      right: areas.right.avg,
      top: areas.top.avg,
      bottom: areas.bottom.avg
    };
  };

  // 動きパターンの分析
  const analyzeMotionPattern = (motion) => {
    motionHistoryRef.current.push(motion);
    if (motionHistoryRef.current.length > 15) {
      motionHistoryRef.current.shift();
    }

    if (motionHistoryRef.current.length < 5) return null;

    const recent = motionHistoryRef.current.slice(-5);
    const avg = recent.reduce((a, b) => a + b.overall, 0) / recent.length;
    const variance = recent.reduce((a, b) => a + Math.pow(b.overall - avg, 2), 0) / recent.length;
    const isSpike = motion.overall > avg + Math.sqrt(variance) * 2;
    
    // 動きの特徴を分析
    const pattern = {
      isSpike,
      isSustained: motion.overall > 10 && avg > 8,
      isQuick: isSpike && motion.overall > 20,
      centerDominant: motion.center > motion.left && motion.center > motion.right,
      horizontalMotion: (motion.left > motion.center * 0.7) || (motion.right > motion.center * 0.7),
      verticalMotion: (motion.top > 5) || (motion.bottom > 5),
      leftBias: motion.left > motion.right * 1.3,
      rightBias: motion.right > motion.left * 1.3
    };

    return pattern;
  };

  // イベント判定と実況生成
  const generateIntelligentCommentary = (motion, pattern) => {
    const now = Date.now();
    const timeSinceLastEvent = now - lastEventTimeRef.current;
    
    // 最低2秒のインターバル
    if (timeSinceLastEvent < 2000) return;

    let event = null;
    let comment = '';
    let eventType = '';

    // パターンマッチングによるイベント判定
    if (pattern.isQuick && motion.center > 18) {
      // 投球・バットスイング
      if (Math.random() > 0.5) {
        eventType = 'pitch';
        const pitchTypes = [
          'ピッチャー、力強く投げ込んだ! ストライク!',
          'ピッチャー、キレのある球! いいコースに決まりました!',
          '投げました! 低めにズバッと!',
          'ピッチャー、タメを作って... 投げた!',
        ];
        comment = pitchTypes[Math.floor(Math.random() * pitchTypes.length)];
        setGameStats(prev => ({ ...prev, pitches: prev.pitches + 1 }));
      } else {
        eventType = 'swing';
        const swingTypes = [
          'バッター、思い切り振った! 大きなスイング!',
          'フルスイング! 力強いバッティング!',
          '振りました! バットが唸りを上げています!',
          'バッター、会心の一撃を狙います!',
        ];
        comment = swingTypes[Math.floor(Math.random() * swingTypes.length)];
      }
      event = { type: eventType, intensity: 'high', motion: motion.overall };
      
    } else if (pattern.isSpike && motion.overall > 12) {
      // ヒット・フィールディング
      if (pattern.horizontalMotion) {
        eventType = 'hit';
        const hitDirections = pattern.leftBias ? 
          ['打った! レフト方向へ!', '左翼線を抜けていきます!', 'レフトオーバー! 大きな当たり!'] :
          ['ライト方向へ飛んでいく!', '右中間を破る当たり!', 'ライトフライ、追いかけます!'];
        comment = hitDirections[Math.floor(Math.random() * hitDirections.length)];
        setGameStats(prev => ({ ...prev, hits: prev.hits + 1 }));
        event = { type: eventType, intensity: 'high', motion: motion.overall };
      } else {
        eventType = 'catch';
        const catchTypes = [
          'ナイスキャッチ! 守備陣、ファインプレー!',
          'しっかり捕った! 守備の連携、完璧です!',
          '捕球! アウトにしました!',
          '守備陣、素早い反応!',
        ];
        comment = catchTypes[Math.floor(Math.random() * catchTypes.length)];
        setGameStats(prev => ({ ...prev, catches: prev.catches + 1 }));
        event = { type: eventType, intensity: 'medium', motion: motion.overall };
      }
      
    } else if (pattern.isSustained && motion.overall > 8) {
      // 走塁
      if (timeSinceLastEvent > 4000) {
        eventType = 'run';
        const runTypes = [
          'ランナー、スピードに乗っています!',
          '走った! ベースを狙います!',
          '俊足、見せます! いいスタートです!',
          'ランナー、次の塁を狙っています!',
        ];
        comment = runTypes[Math.floor(Math.random() * runTypes.length)];
        if (Math.random() > 0.7) {
          setGameStats(prev => ({ ...prev, runs: prev.runs + 1 }));
        }
        event = { type: eventType, intensity: 'medium', motion: motion.overall };
      }
      
    } else if (motion.overall > 4 && timeSinceLastEvent > 5000) {
      // 準備動作
      eventType = 'preparation';
      const prepTypes = [
        'ピッチャー、サインを確認しています',
        'バッター、構えました',
        '守備陣、集中しています',
        'さあ、次のプレーです',
        'ランナー、リードを取っています',
      ];
      comment = prepTypes[Math.floor(Math.random() * prepTypes.length)];
      event = { type: eventType, intensity: 'low', motion: motion.overall };
    }

    if (comment && event) {
      lastEventTimeRef.current = now;
      
      setCommentary(comment);
      setAllComments(prev => [{
        time: new Date().toLocaleTimeString('ja-JP'),
        timestamp: now,
        text: comment,
        motion: Math.round(motion.overall),
        type: eventType
      }, ...prev.slice(0, 19)]);

      // ハイライト判定（高強度のイベント）
      if (event.intensity === 'high' && motion.overall > 15) {
        setHighlights(prev => [...prev, {
          time: new Date().toLocaleTimeString('ja-JP'),
          timestamp: now,
          text: comment,
          type: eventType,
          motion: Math.round(motion.overall)
        }]);
      }

      // 音声読み上げ
      if (isSpeechEnabled && 'speechSynthesis' in window) {
        speechSynthesis.cancel();
        const utterance = new SpeechSynthesisUtterance(comment);
        utterance.lang = 'ja-JP';
        utterance.rate = 1.15;
        utterance.pitch = eventType === 'hit' ? 1.2 : 1.0;
        speechSynthesis.speak(utterance);
      }

      // 統計更新
      setGameStats(prev => ({
        ...prev,
        totalMotion: prev.totalMotion + motion.overall,
        peakMotion: Math.max(prev.peakMotion, motion.overall)
      }));
    }
  };

  // 動き検出ループ
  const motionDetectionLoop = () => {
    if (!isCommenting) return;
    
    const motion = analyzeMotion();
    const pattern = analyzeMotionPattern(motion);
    
    setMotionLevel(motion.overall);
    
    if (pattern) {
      generateIntelligentCommentary(motion, pattern);
    }
    
    animationRef.current = requestAnimationFrame(motionDetectionLoop);
  };

  // カメラストリームを開始
  const startCamera = async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ 
        video: { facingMode: 'environment', width: 1280, height: 720 },
        audio: false 
      });
      if (videoRef.current) {
        videoRef.current.srcObject = stream;
      }
      streamRef.current = stream;
      setIsStreaming(true);
    } catch (err) {
      alert('カメラへのアクセスが拒否されました: ' + err.message);
    }
  };

  // カメラを停止
  const stopCamera = () => {
    if (streamRef.current) {
      streamRef.current.getTracks().forEach(track => track.stop());
      streamRef.current = null;
    }
    if (animationRef.current) {
      cancelAnimationFrame(animationRef.current);
    }
    if (durationIntervalRef.current) {
      clearInterval(durationIntervalRef.current);
    }
    setIsStreaming(false);
    setIsCommenting(false);
  };

  // 実況開始
  const startCommentary = () => {
    if (!isStreaming) {
      alert('先にカメラを起動してください');
      return;
    }
    setIsCommenting(true);
    setCommentary('実況を開始します! プレーボール!');
    setShowDigest(false);
    
    // 統計リセット
    startTimeRef.current = Date.now();
    setGameStats({
      pitches: 0,
      hits: 0,
      catches: 0,
      runs: 0,
      totalMotion: 0,
      peakMotion: 0,
      duration: 0
    });
    setHighlights([]);
    
    // 経過時間カウント
    durationIntervalRef.current = setInterval(() => {
      setGameStats(prev => ({
        ...prev,
        duration: Math.floor((Date.now() - startTimeRef.current) / 1000)
      }));
    }, 1000);
    
    if (isSpeechEnabled && 'speechSynthesis' in window) {
      const utterance = new SpeechSynthesisUtterance('実況を開始します! プレーボール!');
      utterance.lang = 'ja-JP';
      speechSynthesis.speak(utterance);
    }
    
    previousFrameRef.current = null;
    motionHistoryRef.current = [];
    lastEventTimeRef.current = 0;
    animationRef.current = requestAnimationFrame(motionDetectionLoop);
  };

  // 実況停止とダイジェスト生成
  const stopCommentary = () => {
    setIsCommenting(false);
    if (animationRef.current) {
      cancelAnimationFrame(animationRef.current);
    }
    if (durationIntervalRef.current) {
      clearInterval(durationIntervalRef.current);
    }
    if ('speechSynthesis' in window) {
      speechSynthesis.cancel();
    }
    
    // ダイジェスト表示
    if (highlights.length > 0) {
      setShowDigest(true);
      setCommentary('試合終了! ダイジェストを確認できます');
    }
  };

  // 音声オンオフ切り替え
  const toggleSpeech = () => {
    setIsSpeechEnabled(!isSpeechEnabled);
    if (!isSpeechEnabled && 'speechSynthesis' in window) {
      const utterance = new SpeechSynthesisUtterance('音声をオンにしました');
      utterance.lang = 'ja-JP';
      speechSynthesis.speak(utterance);
    } else if ('speechSynthesis' in window) {
      speechSynthesis.cancel();
    }
  };

  // ダイジェストをテキストでダウンロード
  const downloadDigest = () => {
    const duration = gameStats.duration;
    const minutes = Math.floor(duration / 60);
    const seconds = duration % 60;
    
    let digest = '=== 草野球実況ダイジェスト ===\n\n';
    digest += `試合時間: ${minutes}分${seconds}秒\n`;
    digest += `投球数: ${gameStats.pitches}球\n`;
    digest += `ヒット数: ${gameStats.hits}本\n`;
    digest += `守備プレー: ${gameStats.catches}回\n`;
    digest += `走塁: ${gameStats.runs}回\n`;
    digest += `平均動き: ${(gameStats.totalMotion / allComments.length).toFixed(1)}\n`;
    digest += `最大動き: ${gameStats.peakMotion.toFixed(1)}\n\n`;
    digest += '=== ハイライト ===\n\n';
    
    highlights.forEach((h, i) => {
      digest += `${i + 1}. [${h.time}] ${h.text} (動き: ${h.motion})\n`;
    });
    
    digest += '\n=== 全実況 ===\n\n';
    allComments.slice().reverse().forEach((c, i) => {
      digest += `${i + 1}. [${c.time}] ${c.text}\n`;
    });
    
    const blob = new Blob([digest], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `野球実況_${new Date().toLocaleDateString('ja-JP')}.txt`;
    a.click();
    URL.revokeObjectURL(url);
  };

  // クリーンアップ
  useEffect(() => {
    return () => {
      stopCamera();
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
      if (durationIntervalRef.current) {
        clearInterval(durationIntervalRef.current);
      }
    };
  }, []);

  const formatTime = (seconds) => {
    const m = Math.floor(seconds / 60);
    const s = seconds % 60;
    return `${m}:${s.toString().padStart(2, '0')}`;
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-green-900 via-green-700 to-green-900 p-4">
      <div className="max-w-6xl mx-auto">
        {/* ヘッダー */}
        <div className="bg-white/10 backdrop-blur-md rounded-2xl p-6 mb-4 border border-white/20">
          <h1 className="text-3xl font-bold text-white mb-2 flex items-center gap-3">
            <Camera className="w-8 h-8" />
            草野球リアルタイム実況 PRO
          </h1>
          <p className="text-white/80 text-sm">
            高度な動き検出アルゴリズムで実況生成 + ダイジェスト自動作成
          </p>
        </div>

        <div className="grid grid-cols-1 lg:grid-cols-3 gap-4">
          {/* 左カラム: カメラと統計 */}
          <div className="lg:col-span-2 space-y-4">
            {/* カメラビュー */}
            <div className="bg-black rounded-2xl overflow-hidden shadow-2xl relative">
              <video
                ref={videoRef}
                autoPlay
                playsInline
                muted
                className="w-full aspect-video object-cover"
              />
              {isCommenting && (
                <>
                  <div className="absolute top-4 right-4 bg-red-600 text-white px-3 py-2 rounded-full text-sm font-bold flex items-center gap-2 shadow-lg">
                    <div className="w-2 h-2 bg-white rounded-full animate-pulse"></div>
                    実況中 {formatTime(gameStats.duration)}
                  </div>
                  <div className="absolute bottom-4 left-4 right-4 bg-gradient-to-r from-black/80 to-black/60 backdrop-blur-sm text-white p-3 rounded-lg">
                    <div className="text-xs mb-2 flex justify-between items-center">
                      <span>動き検出レベル</span>
                      <span className="font-mono font-bold">{Math.round(motionLevel)}</span>
                    </div>
                    <div className="h-3 bg-gray-800 rounded-full overflow-hidden">
                      <div 
                        className="h-full bg-gradient-to-r from-green-500 via-yellow-400 to-red-500 transition-all duration-200"
                        style={{ width: `${Math.min(motionLevel * 2.5, 100)}%` }}
                      ></div>
                    </div>
                  </div>
                </>
              )}
            </div>
            
            <canvas ref={canvasRef} style={{ display: 'none' }} />

            {/* コントロール */}
            <div className="bg-white/10 backdrop-blur-md rounded-2xl p-4 border border-white/20">
              <div className="flex gap-3 flex-wrap">
                {!isStreaming ? (
                  <button
                    onClick={startCamera}
                    className="flex-1 min-w-[110px] bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-4 rounded-xl transition flex items-center justify-center gap-2"
                  >
                    <Camera className="w-5 h-5" />
                    カメラ起動
                  </button>
                ) : (
                  <button
                    onClick={stopCamera}
                    className="flex-1 min-w-[110px] bg-red-600 hover:bg-red-700 text-white font-semibold py-3 px-4 rounded-xl transition flex items-center justify-center gap-2"
                  >
                    <Square className="w-5 h-5" />
                    停止
                  </button>
                )}

                {!isCommenting ? (
                  <button
                    onClick={startCommentary}
                    disabled={!isStreaming}
                    className="flex-1 min-w-[110px] bg-green-600 hover:bg-green-700 disabled:bg-gray-600 disabled:opacity-50 text-white font-semibold py-3 px-4 rounded-xl transition flex items-center justify-center gap-2"
                  >
                    <Mic className="w-5 h-5" />
                    実況開始
                  </button>
                ) : (
                  <button
                    onClick={stopCommentary}
                    className="flex-1 min-w-[110px] bg-orange-600 hover:bg-orange-700 text-white font-semibold py-3 px-4 rounded-xl transition flex items-center justify-center gap-2"
                  >
                    <Film className="w-5 h-5" />
                    終了/ダイジェスト
                  </button>
                )}

                <button
                  onClick={toggleSpeech}
                  className={`min-w-[110px] ${isSpeechEnabled ? 'bg-purple-600 hover:bg-purple-700' : 'bg-gray-600 hover:bg-gray-700'} text-white font-semibold py-3 px-4 rounded-xl transition flex items-center justify-center gap-2`}
                >
                  {isSpeechEnabled ? <Volume2 className="w-5 h-5" /> : <VolumeX className="w-5 h-5" />}
                  音声{isSpeechEnabled ? 'ON' : 'OFF'}
                </button>
              </div>
            </div>

            {/* 統計パネル */}
            {(isCommenting || allComments.length > 0) && (
              <div className="bg-white/10 backdrop-blur-md rounded-2xl p-4 border border-white/20">
                <div className="flex items-center gap-2 mb-3">
                  <BarChart3 className="w-5 h-5 text-white" />
                  <h3 className="text-lg font-bold text-white">試合統計</h3>
                </div>
                <div className="grid grid-cols-2 md:grid-cols-4 gap-3">
                  <div className="bg-white/5 rounded-lg p-3 border border-white/10">
                    <div className="text-xs text-white/60 mb-1">投球数</div>
                    <div className="text-2xl font-bold text-white">{gameStats.pitches}</div>
                  </div>
                  <div className="bg-white/5 rounded-lg p-3 border border-white/10">
                    <div className="text-xs text-white/60 mb-1">ヒット</div>
                    <div className="text-2xl font-bold text-green-400">{gameStats.hits}</div>
                  </div>
                  <div className="bg-white/5 rounded-lg p-3 border border-white/10">
                    <div className="text-xs text-white/60 mb-1">守備</div>
                    <div className="text-2xl font-bold text-blue-400">{gameStats.catches}</div>
                  </div>
                  <div className="bg-white/5 rounded-lg p-3 border border-white/10">
                    <div className="text-xs text-white/60 mb-1">走塁</div>
                    <div className="text-2xl font-bold text-yellow-400">{gameStats.runs}</div>
                  </div>
                </div>
              </div>
            )}
          </div>

          {/* 右カラム: 実況とダイジェスト */}
          <div className="space-y-4">
            {/* 現在の実況 */}
            {commentary && !showDigest && (
              <div className="bg-gradient-to-br from-white/15 to-white/5 backdrop-blur-md rounded-2xl p-6 border border-white/30 shadow-xl">
                <div className="flex items-start gap-3">
                  <Mic className="w-6 h-6 text-green-400 flex-shrink-0 mt-1 animate-pulse" />
                  <div className="flex-1">
                    <h3 className="text-sm font-semibold text-white/70 mb-2">実況中</h3>
                    <p className="text-lg text-white font-medium leading-relaxed">
                      {commentary}
                    </p>
                  </div>
                </div>
              </div>
            )}

            {/* ダイジェスト */}
            {showDigest && highlights.length > 0 && (
              <div className="bg-gradient-to-br from-yellow-500/20 to-orange-500/20 backdrop-blur-md rounded-2xl p-6 border border-yellow-400/30 shadow-xl">
                <div className="flex items-center justify-between mb-4">
                  <div className="flex items-center gap-2">
                    <Film className="w-6 h-6 text-yellow-400" />
                    <h3 className="text-xl font-bold text-white">ハイライト</h3>
                  </div>
                  <button
                    onClick={downloadDigest}
                    className="bg-yellow-600 hover:bg-yellow-700 text-white px-3 py-2 rounded-lg text-sm font-semibold flex items-center gap-2 transition"
                  >
                    <Download className="w-4 h-4" />
                    保存
                  </button>
                </div>
                <div className="space-y-3 max-h-[500px] overflow-y-auto">
                  {highlights.map((h, idx) => (
                    <div key={idx} className="bg-white/10 rounded-lg p-3 border border-white/20">
                      <div className="flex justify-between items-start mb-2">
                        <span className="text-xs text-yellow-300 font-semibold">#{idx + 1}</span>
                        <span className="text-xs text-white/60">{h.time}</span>
                      </div>
                      <p className="text-white font-medium mb-1">{h.text}</p>
                      <div className="flex justify-between items-center text-xs">
                        <span className="text-white/50">{h.type}</span>
                        <span className="text-yellow-400 font-mono">動き: {h.motion}</span>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}

            {/* 実況履歴 */}
            {allComments.length > 0 && !showDigest && (
              <div className="bg-white/10 backdrop-blur-md rounded-2xl p-6 border border-white/20">
                <h3 className="text-lg font-bold text-white mb-4">実況履歴</h3>
                <div className="space-y-3 max-h-[400px] overflow-y-auto">
                  {allComments.map((comment, idx) => (
                    <div key={idx} className="bg-white/5 rounded-lg p-3 border border-white/10 hover:bg-white/10 transition">
                      <div className="flex justify-between items-center mb-1">
                        <div className="text-xs text-white/50">{comment.time}</div>
                        <div className="flex items-center gap-2">
                          <span className={`text-xs px-2 py-0.5 rounded ${
                            comment.type === 'hit' ? 'bg-green-500/30 text-green-300' :
                            comment.type === 'pitch' ? 'bg-blue-500/30 text-blue-300' :
                            comment.type === 'catch' ? 'bg-purple-500/30 text-purple-300' :
                            comment.type === 'run' ? 'bg-yellow-500/30 text-yellow-300' :
                            'bg-gray-500/30 text-gray-300'
                          }`}>
                            {comment.type}
                          </span>
                          <span className="text-xs text-green-400 font-mono">{comment.motion}</span>
                        </div>
                      </div>
                      <div className="text-white/90">{comment.text}</div>
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        </div>

        {/* 説明 */}
        <div className="mt-4 bg-white/5 backdrop-blur-md rounded-xl p-4 border border-white/10">
          <p className="text-white/70 text-sm leading-relaxed">
            <strong className="text-white">🔬 高度なアルゴリズム:</strong><br />
            • エリア別動き検出（中央・左右・上下）<br />
            • 動きパターン分析（スパイク・持続・方向性）<br />
            • イベント判定（投球・打撃・守備・走塁）<br />
            • 自動ハイライト抽出<br />
            <br />
            <strong className="text-yellow-300">📊 機能:</strong><br />
            リアルタイム実況 | 試合統計 | ハイライト自動生成 | ダイジェストダウンロード
          </p>
        </div>
      </div>
    </div>
  );
}
